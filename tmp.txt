#!/usr/bin/env python3

import requests
import psycopg2
import shutil
from tqdm import tqdm
from time import sleep
import os
import logging
from math import ceil
import time
import json
from requests.exceptions import RequestException
import re


# Configure logging to capture debug-level logs and provide meaningful output.
logging.basicConfig(level=logging.DEBUG, format='%(message)s')

# Configuration variables for the API and database. These should be set according to your environment.
API_SERVER_URL = "http://0.0.0.0:8041"  # Replace with actual API server URL from servers table.
DB_NAME = "mydatabase"                # Name of the database.
DB_USER = "mydbuser"                # Database user.
DB_PASSWORD = "mypassword"        # Database password.
DB_HOST = "100.109.23.62"                # Database host.

# ===GET CURRENT SERVER===
# Function to get the current server ID.
# The server ID is typically fetched from the servers table in the database.
def get_current_server_id():
    # Hardcoded to return 1. Ideally, this should be dynamic or fetched from a configuration or database.
    return 1  # TODO: Fetch from the servers table (server_id)

# ===DATABASE CONNECTION===
# Function to establish a connection to the PostgreSQL database.
def connect_to_db():
    # Creates a connection to the database using the provided credentials.
    try:
        return psycopg2.connect(dbname=DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST)
    except Exception as e:
        logging.error(f"Failed to connect to the database: {e}")
        raise

# ===CONTENT SELECTION===
# Function to handle user selection of content type: Series or Anime.
# This function prompts the user to input their choice of content type.
# It will continue to ask until a valid selection is made.
# Returns:
# - 'series' for a full series.
# - 'series_episode' for a single episode of a series.
# - 'anime' for a full anime.
# - 'anime_episode' for a single episode of an anime.
def select_content_type():
    while True:
        try:
            # Display the menu options for content type selection.
            print("Select the type of content:")
            print("1. Series")
            print("2. Series Single Episode")
            print("3. Anime")
            print("4. Anime Single Episode")

            # Prompt the user for input.
            user_choice = int(input("Select 1 for Series, 2 for Series Single Episode, "
                                    "3 for Anime, or 4 for Anime Single Episode: ").strip())

            # Check the user input and return the appropriate content type.
            if user_choice == 1:
                return 'series'
            elif user_choice == 2:
                return 'series_episode'
            elif user_choice == 3:
                return 'anime'
            elif user_choice == 4:
                return 'anime_episode'
            else:
                print("Invalid choice. Please enter a number between 1 and 4.")
        except ValueError:
            # Handle cases where the input is not a valid integer.
            print("Invalid input. Please enter a number between 1 and 4.")



# ===FETCH BOT AND CHANNEL INFO===
# Function to get bot and channel info based on content type (series, anime, etc.)
# This function fetches bot and channel information from the database.
# Parameters:
# - content_type: A string indicating the type of content ('series', 'series_episode', 'anime', 'anime_episode').
# Returns:
# - A dictionary containing information about the storage channel, live channel, upload bot, and copy bot.
# - Returns None if any required information is missing or if an invalid content type is provided.
# ===FETCH BOT AND CHANNEL INFO===
def get_bots_and_channels(content_type):
    # Establish a connection to the database.
    conn = connect_to_db()
    cur = conn.cursor()

    # Define SQL query to fetch bot and channel info.
    query = """
    SELECT b.bot_id, b.bot_token, c.channel_id, c.channel_name, c.tg_channel_name, b.bot_name
    FROM bots b
    JOIN channels c ON b.bot_id = c.bot_id
    WHERE c.channel_name LIKE %s
    """

    # Determine the search term based on the content type.
    if content_type in ["series", "series_episode"]:
        search_term = "Series%"
    elif content_type in ["anime", "anime_episode"]:
        search_term = "Anime%"
    else:
        print(f"Invalid content type: {content_type}.")
        return None

    # Execute the query using the search term for content type.
    cur.execute(query, (search_term,))
    result = cur.fetchall()

    # Close the cursor and connection to the database.
    cur.close()
    conn.close()

    # Initialize variables to hold information about different channels and bots.
    storage_channel_info = None
    live_channel_info = None
    upload_bot_info = None
    copy_bot_info = None

    # Iterate through the query results to categorize channels and bots.
    for row in result:
        bot_id, bot_token, channel_id, channel_name, tg_channel_name, bot_name = row

        if "Storage" in channel_name:
            storage_channel_info = {
                "bot_token": bot_token,
                "channel_id": channel_id,
                "tg_channel_name": tg_channel_name
            }
        elif "Files" in channel_name:
            live_channel_info = {
                "bot_token": bot_token,
                "channel_id": channel_id,
                "tg_channel_name": tg_channel_name
            }

        if "Upload" in bot_name:
            upload_bot_info = {
                "bot_token": bot_token,
                "bot_name": bot_name,
                "bot_id": bot_id
            }
        elif "Copy" in bot_name:
            copy_bot_info = {
                "bot_token": bot_token,
                "bot_name": bot_name,
                "bot_id": bot_id
            }

    # Check if all required information was retrieved.
    if not all([storage_channel_info, live_channel_info, upload_bot_info, copy_bot_info]):
        print(f"Missing bot or channel information for content type: {content_type}.")
        return None

    # Return the bot and channel information in a structured dictionary.
    return {
        "storage_channel": storage_channel_info,
        "live_channel": live_channel_info,
        "upload_bot": upload_bot_info,
        "copy_bot": copy_bot_info
    }

# ===UPLOAD MEDIA GROUP===
def upload_media_group(media_group, bot_token, channel_id, season_caption=None):
    """
    Uploads a group of media files (photos, videos, etc.) to a Telegram channel using the sendMediaGroup method.

    Parameters:
        - media_group: List of media objects to upload, with each item containing the type, media file path, thumbnail, and caption.
        - bot_token: The bot's token for authentication with the Telegram API.
        - channel_id: The Telegram channel ID where the media will be uploaded.
        - season_caption: Optional caption to be added to the last item in the media group (typically season header + promo).

    This function relies on make_request_with_retries for handling retries in case of API failures.
    """
    upload_url = f"{API_SERVER_URL}/bot{bot_token}/sendMediaGroup"
    files = {}  # Dictionary to hold file references for the request
    payload = []  # Payload to define the media group structure

    # Validate the media group input to ensure files are in the correct format
    for index, item in enumerate(media_group):
        # Ensure the media file path is valid and the file exists
        if not os.path.isfile(item['media']):
            print(f"Error: Media file {item['media']} does not exist or is not a valid file.")
            continue  # Skip this file and move on to the next

        # Ensure the file name doesn't contain forbidden characters or patterns
        if not re.match(r"^[a-zA-Z0-9_\-\.]+$", os.path.basename(item['media'])):
            print(f"Error: Invalid file name '{item['media']}'. Only alphanumeric characters, underscores, hyphens, and periods are allowed.")
            continue

        # Add the media item to the payload with its attach reference
        payload_item = {
            'type': item['type'],
            'media': f"attach://file{index}",
            'caption': ''  # Set caption to None explicitly
        }

        # Check for a thumbnail and attach it to the payload
        if 'thumb' in item and os.path.isfile(item['thumb']):
            payload_item['thumb'] = f"attach://thumb{index}"
            files[f"thumb{index}"] = open(item['thumb'], 'rb')  # Add thumbnail to files

        payload.append(payload_item)

        # Open the media file and add it to the files dictionary
        files[f"file{index}"] = open(item['media'], 'rb')

    # If no valid media files to upload, exit early
    if not files:
        print("No valid media files to upload.")
        return

    # Add season header and promo to the last media item in the group
    if season_caption:
        payload[-1]['caption'] = f"\n{season_caption}"  # Add season caption here

    # Use make_request_with_retries for the API call
    try:
        response = make_request_with_retries(
            url=upload_url,
            data={
                'chat_id': channel_id,
                'media': json.dumps(payload),  # Serialize the payload
                'parse_mode': 'HTML'  # Set the parse_mode to HTML
            },
            files=files  # Include all opened media and thumbnail files
        )

        # Handle successful or failed responses
        if response.status_code == 200:
            print("Media group uploaded successfully.")
            result = response.json()
            if result.get("ok"):
                # Successfully uploaded, process the response and return message details
                messages = result.get("result")
                message_ids = [msg["message_id"] for msg in messages]
                print(f"Message IDs of uploaded media group: {message_ids}")
                return messages  # Return all messages for further processing (e.g., database updates)
            else:
                print(f"Error in upload response: {result.get('description')}")
                return None
        else:
            print(f"Failed to upload media group. Status code: {response.status_code}")
            print(f"Response: {response.text}")
            raise RequestException("Failed to upload media group.")
    finally:
        # Ensure all files are closed after the request (whether successful or not)
        for file in files.values():
            file.close()



# ===PARSE SERIES TITLE===
def parse_series_title_year(folder_name):
    # Extract series title and year from folder name
    match = re.match(r"^(.*)\.(\d{4})\.", folder_name)
    if match:
        series_title = match.group(1).replace('.', ' ').strip()
        year = match.group(2)
        return f"{series_title} ({year})"
    else:
        raise ValueError("Folder name format is invalid. Expected: <title>.<year>.<IMDbId>")



# ===UPLOAD SERIES===
def upload_series(folder_path, thumb_path, backdrop_path, bot_token, channel_id):
    """
    Uploads a TV series organized by seasons to a Telegram channel.

    Parameters:
        - folder_path: Path to the folder containing the series episodes.
        - thumb_path: Path to the thumbnail image to use for all episodes.
        - backdrop_path: Path to the backdrop image for the series.
        - bot_token: The bot's token for Telegram API authentication.
        - channel_id: The Telegram channel ID where the series will be uploaded.
    """
    # Use the parse_series_title_year function to get the correct series title and year
    series_title_year = parse_series_title_year(os.path.basename(folder_path))

    # Get all video files from the folder
    video_files = sorted([f for f in os.listdir(folder_path) if f.endswith('.mkv')])

    # Organize episodes by season
    seasons = {}
    for video_file in video_files:
        if "S" in video_file and "E" in video_file:
            season_number = video_file.split('S')[1].split('E')[0]
            seasons.setdefault(season_number, []).append(video_file)

    # Upload the backdrop image with the corrected caption
    if backdrop_path:
        send_photo(
            image_path=backdrop_path,
            caption=f"{series_title_year}",  # Corrected series title format for the backdrop
            bot_token=bot_token,
            channel_id=channel_id
        )

    # Upload each season's episodes
    for season, episodes in sorted(seasons.items()):
        print(f"Uploading Season {season} of {series_title_year}...")

        # Prepare the season caption with an extra newline for separation
        season_caption = f"S{season} 🎬 {series_title_year}\n\nJoin 👉@EveryMovieNow"  # Correct HTML format for bold

        # Divide episodes into groups of 10 (Telegram limit for media groups)
        num_groups = ceil(len(episodes) / 10)
        for group_index in range(num_groups):
            group_episodes = episodes[group_index * 10: (group_index + 1) * 10]

            # Create a media group for the current batch of episodes
            media_group = []
            for index, episode in enumerate(group_episodes):
                episode_path = os.path.join(folder_path, episode)
                media_group.append({
                    'type': 'document',
                    'media': episode_path,
                    'thumb': thumb_path,  # Attach the thumbnail to each file
                    'caption': ''  # Blank captions for all files initially
                })

            # Add the season caption to the last item in the media group
            media_group[-1]['caption'] = season_caption

            # Upload the media group with the season caption at the bottom
            upload_media_group(
                media_group=media_group,
                bot_token=bot_token,
                channel_id=channel_id,
                season_caption=season_caption  # season_caption is already included in media group captions
            )

            # Wait before uploading the next group (Telegram's limit of 30 uploads per minute)
            time.sleep(20)

        # Wait before moving to the next season (to avoid hitting API rate limits)
        time.sleep(20)
        print(f"Season {season} of {series_title_year} uploaded successfully!\n")

# ===COPY MESSAGE===
# Function to copy the message to the live channel
def copy_message_to_live_channel(message_id, bot_token_copy, live_channel_id, storage_channel_id, message_type="file"):
    """
    This function uses make_request_with_retries for API calls and handles basic input validation.
    """
    # Validate message_id to ensure it's a valid integer (positive number)
    if not isinstance(message_id, int) or message_id <= 0:
        raise ValueError(f"Error: Invalid message ID '{message_id}'. It should be a positive integer.")

    # Validate that live_channel_id and storage_channel_id are valid (integer or string)
    if not isinstance(live_channel_id, (int, str)) or not isinstance(storage_channel_id, (int, str)):
        raise ValueError("Error: Both live_channel_id and storage_channel_id should be valid integers or strings.")

    # Ensure the message_type is one of the allowed values ('file', 'photo', 'text')
    if message_type not in ['file', 'photo', 'text']:
        raise ValueError(f"Error: Invalid message type '{message_type}'. Must be one of ['file', 'photo', 'text'].")

    copy_url = f"{API_SERVER_URL}/bot{bot_token_copy}/copyMessage"

    # Prepare the data payload
    data = {
        'chat_id': live_channel_id,
        'from_chat_id': storage_channel_id,
        'message_id': message_id
    }

    # Make the API request with retries
    response = make_request_with_retries(
        url=copy_url,
        data=data
    )

    # Handle successful response
    if response.status_code == 200:
        print(f"{message_type.capitalize()} message copied to live channel successfully!")
        return response.json().get('result')

    else:
        print(f"Failed to copy {message_type} message. Status code: {response.status_code}")
        print(f"Response: {response.text}")
        raise RequestException(f"Failed to copy {message_type} message.")

# ===MAIN FUNCTION===
# Main script logic
def main():
    # Step 1: Prompt the user to select the content type (Series/Anime)
    content_type_choice = select_content_type()

    # Step 2: Map the selected content type to the corresponding database and query logic
    if content_type_choice in ['series', 'series_episode']:
        content_type = "series"
    elif content_type_choice in ['anime', 'anime_episode']:
        content_type = "anime"

    print(f"Uploading content type: {content_type.capitalize()}")

    # Step 3: Fetch the relevant bot and channel information
    bots_and_channels = get_bots_and_channels(content_type)
    if not bots_and_channels:
        print("Failed to retrieve bot or channel information. Exiting.")
        return

    # Extract bot and channel details
    storage_channel = bots_and_channels["storage_channel"]
    live_channel = bots_and_channels["live_channel"]
    upload_bot = bots_and_channels["upload_bot"]
    copy_bot = bots_and_channels["copy_bot"]

    # Step 4: Use the current working directory for media files
    folder_path = os.getcwd()

    # Step 5: Check for a thumbnail and backdrop in the 'reference' folder
    thumb_file_path = None
    backdrop_path = None
    reference_dir = os.path.join(os.getcwd(), 'reference')
    if os.path.exists(reference_dir):
        for file in os.listdir(reference_dir):
            if file.endswith('_thumb.jpg'):
                thumb_file_path = os.path.join(reference_dir, file)
            elif file == 'backdrop.jpg':
                backdrop_path = os.path.join(reference_dir, file)

    # If no thumbnail is found, print an error and exit
    if not thumb_file_path:
        print("Error: No thumbnail file found in the 'reference' folder.")
        return

    # Step 6: Upload the series or anime
    print(f"Uploading content from folder: {folder_path}")
    uploaded_messages = upload_series(
        folder_path,
        thumb_file_path,
        backdrop_path,
        upload_bot["bot_token"],
        storage_channel["channel_id"]
    )

    # Validate if uploaded messages were returned
    if not uploaded_messages:
        print("Error: No messages were uploaded. Exiting.")
        return

    # Step 7: Ask if the user wants to copy the content to the live channel
    copy_choice = input("Copy this content to the live channel? (Y/N): ").strip().lower()
    if copy_choice in ['y', 'yes']:
        print("Waiting 3 minutes before copying...")
        sleep(20)

        # Copy uploaded messages to the live channel
        for message in uploaded_messages:
            copy_result = copy_message_to_live_channel(
                message['message_id'],
                copy_bot["bot_token"],
                live_channel["channel_id"],
                storage_channel["channel_id"]
            )

            if copy_result:
                # Update the database with copied message details
                copy_message_id = copy_result['message_id']
                update_database_after_copy(
                    message['message_id'],
                    copy_message_id,
                    copy_bot["bot_id"],
                    live_channel["channel_id"],
                    content_type
                )

# Run the main function when the script is executed
if __name__ == "__main__":
    main()
